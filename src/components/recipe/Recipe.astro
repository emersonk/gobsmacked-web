---

---

<div class="parent"></div>

<script>
// Types
interface StepIngredient {
  id: number;
  amount: string | null;
}

interface RecipeStep {
  id: number;
  action: string;
  options: string | null;
  parents: number[] | null;
  ingredients: StepIngredient[] | null;
}

interface Ingredient {
  id: number;
  name: string;
  quantity: string | null;
  mise_en_place: string | null;
  options: string | null;
  notes: string | null;
}

interface GridPlacement {
  currentGridRowStart: number;
  currentGridColumnStart: number;
  nextGridRowStart: number;
  nextGridColumnStart: number;
  borderRadius: number;
  alignItems: string;
}

interface IngredientPlacement {
  currentGridRowStart: number;
  quantity: string | null;
  ingredient: string;
  amount: string | null;
  miseEnPlace: string | null;
}

// Core calculation logic
class RecipeGridCalculator {
  private steps: RecipeStep[];
  private ingredients: Ingredient[];
  private gridPlacementSteps: Record<number, GridPlacement> = {};
  private gridPlacementIngredients: Record<number, IngredientPlacement> = {};
  private columnEndPointer = 5;
  private numIngredientsCounter = 0;

  constructor(steps: RecipeStep[], ingredients: Ingredient[]) {
    this.steps = steps;
    this.ingredients = ingredients;
  }

  calculate(): [number, Record<number, GridPlacement>, Record<number, IngredientPlacement>] {
    const sortedSteps = this.topologicalSort();
    this.processSteps(sortedSteps);
    return [this.columnEndPointer - 1, this.gridPlacementSteps, this.gridPlacementIngredients];
  }

  private processSteps(sortedSteps: RecipeStep[]): void {
    let currentGridRowStart = 1;
    let nextGridRowStart = 1;
    let currentGridColumnStart = 4;
    let nextGridColumnStart = 4;

    sortedSteps.forEach((step, index) => {
      const placement = this.calculateStepPlacement(
        step,
        currentGridRowStart,
        currentGridColumnStart,
        nextGridRowStart,
        nextGridColumnStart,
        index,
        sortedSteps
      );

      this.gridPlacementSteps[step.id] = placement;
      
      // Update positions for next iteration
      currentGridRowStart = placement.nextGridRowStart;
      if (step.parents?.length ?? 0 >= 1) {
        this.columnEndPointer++;
      }
    });
  }

  private calculateStepPlacement(
    step: RecipeStep,
    currentGridRowStart: number,
    currentGridColumnStart: number,
    nextGridRowStart: number,
    nextGridColumnStart: number,
    index: number,
    sortedSteps: RecipeStep[]
  ): GridPlacement {
    const numOfIngredientsAddedInStep = this.processStepIngredients(step);
    const numParents = step.parents?.length ?? 0;

    const gridPosition = this.calculateGridPosition(
      step,
      numOfIngredientsAddedInStep,
      numParents,
      currentGridRowStart,
      currentGridColumnStart
    );

    return {
      ...gridPosition,
      borderRadius: this.calculateBorderRadius(index, sortedSteps),
      alignItems: numOfIngredientsAddedInStep === 1 ? "end" : "center"
    };
  }

  private processStepIngredients(step: RecipeStep): number {
    const stepIngredients = step.ingredients ?? [];
    stepIngredients.forEach(ingredient => {
      const fullIngredient = this.ingredients.find(x => x.id === ingredient.id);
      if (fullIngredient) {
        this.gridPlacementIngredients[this.numIngredientsCounter] = {
          currentGridRowStart: this.numIngredientsCounter + 1,
          quantity: fullIngredient.quantity,
          ingredient: fullIngredient.name,
          amount: ingredient.amount,
          miseEnPlace: fullIngredient.mise_en_place
        };
        this.numIngredientsCounter++;
      }
    });
    return stepIngredients.length;
  }

  private calculateGridPosition(
    step: RecipeStep,
    numOfIngredientsAddedInStep: number,
    numParents: number,
    currentGridRowStart: number,
    currentGridColumnStart: number
  ): Pick<GridPlacement, 'currentGridRowStart' | 'currentGridColumnStart' | 'nextGridRowStart' | 'nextGridColumnStart'> {
    if (numParents === 0 && numOfIngredientsAddedInStep >= 1) {
      return this.calculatePositionForNewIngredients(
        currentGridRowStart,
        numOfIngredientsAddedInStep
      );
    }
    
    if (numParents >= 1) {
      return this.calculatePositionWithParents(
        step,
        numOfIngredientsAddedInStep
      );
    }

    return {
      currentGridRowStart,
      currentGridColumnStart,
      nextGridRowStart: currentGridRowStart + numOfIngredientsAddedInStep,
      nextGridColumnStart: this.columnEndPointer
    };
  }

  private calculatePositionForNewIngredients(
    currentGridRowStart: number,
    numOfIngredientsAdded: number
  ): Pick<GridPlacement, 'currentGridRowStart' | 'currentGridColumnStart' | 'nextGridRowStart' | 'nextGridColumnStart'> {
    return {
      currentGridRowStart,
      currentGridColumnStart: 4,
      nextGridRowStart: currentGridRowStart + numOfIngredientsAdded,
      nextGridColumnStart: this.columnEndPointer
    };
  }

  private calculatePositionWithParents(
    step: RecipeStep,
    numOfIngredientsAdded: number
  ): Pick<GridPlacement, 'currentGridRowStart' | 'currentGridColumnStart' | 'nextGridRowStart' | 'nextGridColumnStart'> {
    const parentPlacements = step.parents
      ?.map(parentId => this.gridPlacementSteps[parentId])
      .filter(Boolean) ?? [];

    if (numOfIngredientsAdded === 0) {
      return {
        currentGridRowStart: Math.min(...parentPlacements.map(p => p.currentGridRowStart)),
        currentGridColumnStart: Math.max(...parentPlacements.map(p => p.nextGridColumnStart)),
        nextGridRowStart: Math.max(...parentPlacements.map(p => p.nextGridRowStart)),
        nextGridColumnStart: Math.max(...parentPlacements.map(p => p.nextGridColumnStart)) + 1
      };
    }

    return {
      currentGridRowStart: 1,
      currentGridColumnStart: 4,
      nextGridRowStart: Math.max(...parentPlacements.map(p => p.nextGridRowStart)) + numOfIngredientsAdded,
      nextGridColumnStart: Math.max(...parentPlacements.map(p => p.nextGridColumnStart)) + 1
    };
  }

  private calculateBorderRadius(index: number, sortedSteps: RecipeStep[]): number {
    if (index + 1 < sortedSteps.length) {
      return (sortedSteps[index + 1].ingredients?.length ?? 0) >= 1 ? 20 : 0;
    }
    return 0;
  }

  private topologicalSort(): RecipeStep[] {
    const graph = new Map<number, RecipeStep>();
    const visited = new Set<number>();
    const sortedSteps: RecipeStep[] = [];

    this.steps.forEach(step => graph.set(step.id, step));

    const visit = (step: RecipeStep): void => {
      if (visited.has(step.id)) return;
      visited.add(step.id);

      step.parents?.forEach(parentId => {
        const parent = graph.get(parentId);
        if (parent && !visited.has(parentId)) {
          visit(parent);
        }
      });

      sortedSteps.push(step);
    };

    this.steps.forEach(step => {
      if (!visited.has(step.id)) {
        visit(step);
      }
    });

    return sortedSteps;
  }
}

// HTML/CSS Generator
class RecipeGridRenderer {
  private numberOfColumns: number;
  private gridPlacementSteps: Record<number, GridPlacement>;
  private gridPlacementIngredients: Record<number, IngredientPlacement>;
  private steps: RecipeStep[];

  constructor(
    numberOfColumns: number,
    gridPlacementSteps: Record<number, GridPlacement>,
    gridPlacementIngredients: Record<number, IngredientPlacement>,
    steps: RecipeStep[]
  ) {
    this.numberOfColumns = numberOfColumns;
    this.gridPlacementSteps = gridPlacementSteps;
    this.gridPlacementIngredients = gridPlacementIngredients;
    this.steps = steps;
  }

  render(): HTMLDivElement {
    const container = document.createElement("div");
    container.innerHTML = this.generateHTML();
    
    const styleElement = document.createElement("style");
    styleElement.textContent = this.generateCSS();
    container.appendChild(styleElement);

    return container;
  }

  private generateCSS(): string {
    let css = `
      .parent {
        grid-template-columns: repeat(${this.numberOfColumns}, 1fr);
        grid-template-rows: repeat(${this.steps.length}, 1fr);
      }`;

    // Step styles
    Object.entries(this.gridPlacementSteps).forEach(([id, placement]) => {
      css += `
        .step-${id} {
          grid-area: ${placement.currentGridRowStart} / ${placement.currentGridColumnStart} / ${placement.nextGridRowStart} / ${placement.nextGridColumnStart};
          align-items: ${placement.alignItems};
          border-bottom-right-radius: ${placement.borderRadius}px;
        }`;
    });

    // Ingredient styles
    Object.entries(this.gridPlacementIngredients).forEach(([key, value]) => {
      css += `
        .quantity-${key} {
          grid-area: ${value.currentGridRowStart} / 1 / ${value.currentGridRowStart + 1} / 2;
        }
        .name-${key} {
          grid-area: ${value.currentGridRowStart} / 2 / ${value.currentGridRowStart + 1} / 3;
        }
        .mep-${key} {
          grid-area: ${value.currentGridRowStart} / 3 / ${value.currentGridRowStart + 1} / 4;
        }`;
    });

    return css;
  }

  private generateHTML(): string {
    const ingredientHTML = Object.entries(this.gridPlacementIngredients)
      .map(([key, value]) => `
        <div class="quantity-${key}">${value.quantity ?? ""}</div>
        <div class="name-${key}">${value.ingredient ?? ""}</div>
        <div class="mep-${key}">${value.miseEnPlace ?? value.amount ?? ""}</div>
      `)
      .join("");

    const stepsHTML = this.steps
      .map(step => `<div class="step-${step.id}">${step.action}</div>`)
      .join("");

    return ingredientHTML + stepsHTML;
  }
}

// Main function
function generateRecipeGrid(recipeSteps: RecipeStep[], ingredients: Ingredient[]): HTMLDivElement {
  const calculator = new RecipeGridCalculator(recipeSteps, ingredients);
  const [numberOfColumns, gridPlacementSteps, gridPlacementIngredients] = calculator.calculate();

  const renderer = new RecipeGridRenderer(
    numberOfColumns,
    gridPlacementSteps,
    gridPlacementIngredients,
    recipeSteps
  );

  return renderer.render();
}

// Usage function
function renderRecipeGrid(stepsJson: string, ingredientsJson: string): void {
  const recipeSteps: RecipeStep[] = JSON.parse(stepsJson).steps;
  const ingredients: Ingredient[] = JSON.parse(ingredientsJson).ingredients;
  
  const gridContainer = generateRecipeGrid(recipeSteps, ingredients);
  
  const parentDiv = document.querySelector(".parent");
  if (parentDiv) {
    parentDiv.append(...gridContainer.children);
  }
}

  const rawIngredients = {
    ingredients: [
      {
        id: 1,
        name: "lamb roast",
        quantity: "1 large, 4 to 6 pounds",
        mise_en_place: null,
        options:
          "bone-in leg (these can be as large as 8 pounds), semiboneless leg, bone-in shoulder, boneless butterflied leg or double loin",
        notes: "with a cap of fat",
      },
      {
        id: 2,
        name: "anchovies",
        quantity: "2 ounces (1 can)",
        mise_en_place: null,
        options: "3 tablespoons Dijon mustard",
        notes: "packed in olive oil, drained",
      },
      {
        id: 3,
        name: "fresh rosemary",
        quantity: "Leaves from 6 sprigs (2 heaping tablespoons leaves)",
        mise_en_place: null,
        options: null,
        notes: "plus extra sprigs and branches for garnish",
      },
      {
        id: 4,
        name: "garlic cloves",
        quantity: "6",
        mise_en_place: "smashed and peeled",
        options: null,
        notes: null,
      },
      {
        id: 5,
        name: "unsalted butter",
        quantity: "4 ounces",
        mise_en_place: "softened at room temperature",
        options: null,
        notes: null,
      },
      {
        id: 6,
        name: "black pepper",
        quantity: null,
        mise_en_place: null,
        options: null,
        notes: null,
      },
      {
        id: 7,
        name: "lemon",
        quantity: "1",
        mise_en_place: "cut in half",
        options: null,
        notes: null,
      },
      {
        id: 8,
        name: "white wine",
        quantity: "1¾ cups",
        mise_en_place: null,
        options: null,
        notes: "plus extra for gravy",
      },
    ],
  };

  const recipeSteps = {
    steps: [
      {
        id: 1,
        action: "make incisions",
        options: null,
        parents: null,
        ingredients: [
          {
            id: 1,
            amount: null,
          },
        ],
      },
      {
        id: 2,
        action: "blend into a chunky paste",
        options: "using a mortar and pestle or a blender",
        parents: null,
        ingredients: [
          {
            id: 2,
            amount: "⅔",
          },
          {
            id: 3,
            amount: null,
          },
          {
            id: 4,
            amount: null,
          },
        ],
      },
      {
        id: 3,
        action: "press paste deeply into incisions",
        options: null,
        parents: [1, 2],
        ingredients: null,
      },
      {
        id: 4,
        action: "mix into a paste",
        options: null,
        parents: null,
        ingredients: [
          {
            id: 2,
            amount: "⅓",
          },
          {
            id: 5,
            amount: null,
          },
        ],
      },
      {
        id: 5,
        action: "smear mixture all over the surface",
        options: null,
        parents: [1, 4],
        ingredients: null,
      },
      {
        id: 6,
        action: "season liberally",
        options: null,
        parents: [5],
        ingredients: [
          {
            id: 6,
            amount: null,
          },
        ],
      },
      {
        id: 7,
        action: "place on a rack in a roasting pan, fat side up",
        options: null,
        parents: [6],
        ingredients: null,
      },
      {
        id: 8,
        action: "squeeze over",
        options: null,
        parents: [7],
        ingredients: [
          {
            id: 7,
            amount: null,
          },
        ],
      },
      {
        id: 9,
        action: "pour around the roast into the pan",
        options: null,
        parents: [8],
        ingredients: [
          {
            id: 8,
            amount: null,
          },
        ],
      },
    ],
  };

  renderRecipeGrid(JSON.stringify(recipeSteps), JSON.stringify(rawIngredients));
</script>
